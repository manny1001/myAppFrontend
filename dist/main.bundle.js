/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./App.js":
/*!****************!*\
  !*** ./App.js ***!
  \****************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (56:4)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n| \\n|   return (\\n>     <NavigationContainer\\n|       ref={navigationRef}\\n|       /* onReady={() => {\");\n\n//# sourceURL=webpack://myAppFrontend/./App.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var expo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! expo */ \"./node_modules/expo/build/launch/registerRootComponent.js\");\n/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App */ \"./App.js\");\n/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_App__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\n\r\n\r\n// registerRootComponent calls AppRegistry.registerComponent('main', () => App);\r\n// It also ensures that whether you load the app in the Expo client or in a native build,\r\n// the environment is set up appropriately\r\n(0,expo__WEBPACK_IMPORTED_MODULE_1__[\"default\"])((_App__WEBPACK_IMPORTED_MODULE_0___default()));\r\n\n\n//# sourceURL=webpack://myAppFrontend/./index.js?");

/***/ }),

/***/ "./node_modules/@react-native/assets-registry/registry.js":
/*!****************************************************************!*\
  !*** ./node_modules/@react-native/assets-registry/registry.js ***!
  \****************************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (13:7)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n| 'use strict';\\n| \\n> export type PackagerAsset = {\\n|   +__packager_asset: boolean,\\n|   +fileSystemLocation: string,\");\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/@react-native/assets-registry/registry.js?");

/***/ }),

/***/ "./node_modules/expo-asset/build/Asset.js":
/*!************************************************!*\
  !*** ./node_modules/expo-asset/build/Asset.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Asset: () => (/* binding */ Asset)\n/* harmony export */ });\n/* harmony import */ var _react_native_assets_registry_registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-native/assets-registry/registry */ \"./node_modules/@react-native/assets-registry/registry.js\");\n/* harmony import */ var _react_native_assets_registry_registry__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_react_native_assets_registry_registry__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var expo_modules_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! expo-modules-core */ \"./node_modules/expo-modules-core/build/Platform.js\");\n/* harmony import */ var _AssetSources__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./AssetSources */ \"./node_modules/expo-asset/build/AssetSources.js\");\n/* harmony import */ var _AssetUris__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AssetUris */ \"./node_modules/expo-asset/build/AssetUris.js\");\n/* harmony import */ var _ExpoAsset__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ExpoAsset */ \"./node_modules/expo-asset/build/ExpoAsset.js\");\n/* harmony import */ var _ImageAssets__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ImageAssets */ \"./node_modules/expo-asset/build/ImageAssets.js\");\n/* harmony import */ var _LocalAssets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LocalAssets */ \"./node_modules/expo-asset/build/LocalAssets.js\");\n/* harmony import */ var _PlatformUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PlatformUtils */ \"./node_modules/expo-asset/build/PlatformUtils.js\");\n/* harmony import */ var _resolveAssetSource__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./resolveAssetSource */ \"./node_modules/expo-asset/build/resolveAssetSource.js\");\n\n\n\n\n\n\n\n\n\n/**\n * The `Asset` class represents an asset in your app. It gives metadata about the asset (such as its\n * name and type) and provides facilities to load the asset data.\n */\nclass Asset {\n    static byHash = {};\n    static byUri = {};\n    /**\n     * The name of the asset file without the extension. Also without the part from `@` onward in the\n     * filename (used to specify scale factor for images).\n     */\n    name;\n    /**\n     * The extension of the asset filename.\n     */\n    type;\n    /**\n     * The MD5 hash of the asset's data.\n     */\n    hash = null;\n    /**\n     * A URI that points to the asset's data on the remote server. When running the published version\n     * of your app, this refers to the location on Expo's asset server where Expo has stored your\n     * asset. When running the app from Expo CLI during development, this URI points to Expo CLI's\n     * server running on your computer and the asset is served directly from your computer. If you\n     * are not using Classic Updates (legacy), this field should be ignored as we ensure your assets\n     * are on device before before running your application logic.\n     */\n    uri;\n    /**\n     * If the asset has been downloaded (by calling [`downloadAsync()`](#downloadasync)), the\n     * `file://` URI pointing to the local file on the device that contains the asset data.\n     */\n    localUri = null;\n    /**\n     * If the asset is an image, the width of the image data divided by the scale factor. The scale\n     * factor is the number after `@` in the filename, or `1` if not present.\n     */\n    width = null;\n    /**\n     * If the asset is an image, the height of the image data divided by the scale factor. The scale factor is the number after `@` in the filename, or `1` if not present.\n     */\n    height = null;\n    downloading = false;\n    /**\n     * Whether the asset has finished downloading from a call to [`downloadAsync()`](#downloadasync).\n     */\n    downloaded = false;\n    _downloadCallbacks = [];\n    constructor({ name, type, hash = null, uri, width, height }) {\n        this.name = name;\n        this.type = type;\n        this.hash = hash;\n        this.uri = uri;\n        if (typeof width === 'number') {\n            this.width = width;\n        }\n        if (typeof height === 'number') {\n            this.height = height;\n        }\n        if (hash) {\n            this.localUri = (0,_LocalAssets__WEBPACK_IMPORTED_MODULE_1__.getLocalAssetUri)(hash, type);\n            if (this.localUri) {\n                this.downloaded = true;\n            }\n        }\n        if (expo_modules_core__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OS === 'web') {\n            if (!name) {\n                this.name = _AssetUris__WEBPACK_IMPORTED_MODULE_3__.getFilename(uri);\n            }\n            if (!type) {\n                this.type = _AssetUris__WEBPACK_IMPORTED_MODULE_3__.getFileExtension(uri);\n            }\n        }\n    }\n    // @needsAudit\n    /**\n     * A helper that wraps `Asset.fromModule(module).downloadAsync` for convenience.\n     * @param moduleId An array of `require('path/to/file')` or external network URLs. Can also be\n     * just one module or URL without an Array.\n     * @return Returns a Promise that fulfills with an array of `Asset`s when the asset(s) has been\n     * saved to disk.\n     * @example\n     * ```ts\n     * const [{ localUri }] = await Asset.loadAsync(require('./assets/snack-icon.png'));\n     * ```\n     */\n    static loadAsync(moduleId) {\n        const moduleIds = Array.isArray(moduleId) ? moduleId : [moduleId];\n        return Promise.all(moduleIds.map((moduleId) => Asset.fromModule(moduleId).downloadAsync()));\n    }\n    // @needsAudit\n    /**\n     * Returns the [`Asset`](#asset) instance representing an asset given its module or URL.\n     * @param virtualAssetModule The value of `require('path/to/file')` for the asset or external\n     * network URL\n     * @return The [`Asset`](#asset) instance for the asset.\n     */\n    static fromModule(virtualAssetModule) {\n        if (typeof virtualAssetModule === 'string') {\n            return Asset.fromURI(virtualAssetModule);\n        }\n        const meta = (0,_react_native_assets_registry_registry__WEBPACK_IMPORTED_MODULE_0__.getAssetByID)(virtualAssetModule);\n        if (!meta) {\n            throw new Error(`Module \"${virtualAssetModule}\" is missing from the asset registry`);\n        }\n        // Outside of the managed env we need the moduleId to initialize the asset\n        // because resolveAssetSource depends on it\n        if (!_PlatformUtils__WEBPACK_IMPORTED_MODULE_4__.IS_ENV_WITH_LOCAL_ASSETS) {\n            // null-check is performed above with `getAssetByID`.\n            const { uri } = (0,_resolveAssetSource__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(virtualAssetModule);\n            const asset = new Asset({\n                name: meta.name,\n                type: meta.type,\n                hash: meta.hash,\n                uri,\n                width: meta.width,\n                height: meta.height,\n            });\n            // For images backward compatibility,\n            // keeps localUri the same as uri for React Native's Image that\n            // works fine with drawable resource names.\n            if (expo_modules_core__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OS === 'android' && !uri.includes(':') && (meta.width || meta.height)) {\n                asset.localUri = asset.uri;\n                asset.downloaded = true;\n            }\n            Asset.byHash[meta.hash] = asset;\n            return asset;\n        }\n        return Asset.fromMetadata(meta);\n    }\n    // @docsMissing\n    static fromMetadata(meta) {\n        // The hash of the whole asset, not to be confused with the hash of a specific file returned\n        // from `selectAssetSource`\n        const metaHash = meta.hash;\n        if (Asset.byHash[metaHash]) {\n            return Asset.byHash[metaHash];\n        }\n        const { uri, hash } = (0,_AssetSources__WEBPACK_IMPORTED_MODULE_6__.selectAssetSource)(meta);\n        const asset = new Asset({\n            name: meta.name,\n            type: meta.type,\n            hash,\n            uri,\n            width: meta.width,\n            height: meta.height,\n        });\n        Asset.byHash[metaHash] = asset;\n        return asset;\n    }\n    // @docsMissing\n    static fromURI(uri) {\n        if (Asset.byUri[uri]) {\n            return Asset.byUri[uri];\n        }\n        // Possibly a Base64-encoded URI\n        let type = '';\n        if (uri.indexOf(';base64') > -1) {\n            type = uri.split(';')[0].split('/')[1];\n        }\n        else {\n            const extension = _AssetUris__WEBPACK_IMPORTED_MODULE_3__.getFileExtension(uri);\n            type = extension.startsWith('.') ? extension.substring(1) : extension;\n        }\n        const asset = new Asset({\n            name: '',\n            type,\n            hash: null,\n            uri,\n        });\n        Asset.byUri[uri] = asset;\n        return asset;\n    }\n    // @needsAudit\n    /**\n     * Downloads the asset data to a local file in the device's cache directory. Once the returned\n     * promise is fulfilled without error, the [`localUri`](#localuri) field of this asset points\n     * to a local file containing the asset data. The asset is only downloaded if an up-to-date local\n     * file for the asset isn't already present due to an earlier download. The downloaded `Asset`\n     * will be returned when the promise is resolved.\n     * @return Returns a Promise which fulfills with an `Asset` instance.\n     */\n    async downloadAsync() {\n        if (this.downloaded) {\n            return this;\n        }\n        if (this.downloading) {\n            await new Promise((resolve, reject) => {\n                this._downloadCallbacks.push({ resolve, reject });\n            });\n            return this;\n        }\n        this.downloading = true;\n        try {\n            if (expo_modules_core__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OS === 'web') {\n                if (_ImageAssets__WEBPACK_IMPORTED_MODULE_7__.isImageType(this.type)) {\n                    const { width, height, name } = await _ImageAssets__WEBPACK_IMPORTED_MODULE_7__.getImageInfoAsync(this.uri);\n                    this.width = width;\n                    this.height = height;\n                    this.name = name;\n                }\n                else {\n                    this.name = _AssetUris__WEBPACK_IMPORTED_MODULE_3__.getFilename(this.uri);\n                }\n            }\n            this.localUri = await (0,_ExpoAsset__WEBPACK_IMPORTED_MODULE_8__.downloadAsync)(this.uri, this.hash, this.type);\n            this.downloaded = true;\n            this._downloadCallbacks.forEach(({ resolve }) => resolve());\n        }\n        catch (e) {\n            this._downloadCallbacks.forEach(({ reject }) => reject(e));\n            throw e;\n        }\n        finally {\n            this.downloading = false;\n            this._downloadCallbacks = [];\n        }\n        return this;\n    }\n}\n//# sourceMappingURL=Asset.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-asset/build/Asset.js?");

/***/ }),

/***/ "./node_modules/expo-asset/build/AssetSourceResolver.js":
/*!**************************************************************!*\
  !*** ./node_modules/expo-asset/build/AssetSourceResolver.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AssetSourceResolver)\n/* harmony export */ });\n/* harmony import */ var expo_modules_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! expo-modules-core */ \"./node_modules/expo-modules-core/build/Platform.js\");\n/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-native */ \"./node_modules/react-native/index.js\");\n/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_native__WEBPACK_IMPORTED_MODULE_0__);\n\n\n// Returns the Metro dev server-specific asset location.\nfunction getScaledAssetPath(asset) {\n    const scale = AssetSourceResolver.pickScale(asset.scales, react_native__WEBPACK_IMPORTED_MODULE_0__.PixelRatio.get());\n    const scaleSuffix = scale === 1 ? '' : '@' + scale + 'x';\n    const type = !asset.type ? '' : `.${asset.type}`;\n    if (__DEV__) {\n        return asset.httpServerLocation + '/' + asset.name + scaleSuffix + type;\n    }\n    else {\n        return asset.httpServerLocation.replace(/\\.\\.\\//g, '_') + '/' + asset.name + scaleSuffix + type;\n    }\n}\nclass AssetSourceResolver {\n    serverUrl;\n    // where the jsbundle is being run from\n    // NOTE(EvanBacon): Never defined on web.\n    jsbundleUrl;\n    // the asset to resolve\n    asset;\n    constructor(serverUrl, jsbundleUrl, asset) {\n        this.serverUrl = serverUrl || 'https://expo.dev';\n        this.jsbundleUrl = null;\n        this.asset = asset;\n    }\n    // Always true for web runtimes\n    isLoadedFromServer() {\n        return true;\n    }\n    // Always false for web runtimes\n    isLoadedFromFileSystem() {\n        return false;\n    }\n    defaultAsset() {\n        return this.assetServerURL();\n    }\n    /**\n     * @returns absolute remote URL for the hosted asset.\n     */\n    assetServerURL() {\n        const fromUrl = new URL(getScaledAssetPath(this.asset), this.serverUrl);\n        fromUrl.searchParams.set('platform', expo_modules_core__WEBPACK_IMPORTED_MODULE_1__[\"default\"].OS);\n        fromUrl.searchParams.set('hash', this.asset.hash);\n        return this.fromSource(\n        // Relative on web\n        fromUrl.toString().replace(fromUrl.origin, ''));\n    }\n    fromSource(source) {\n        return {\n            __packager_asset: true,\n            width: this.asset.width ?? undefined,\n            height: this.asset.height ?? undefined,\n            uri: source,\n            scale: AssetSourceResolver.pickScale(this.asset.scales, react_native__WEBPACK_IMPORTED_MODULE_0__.PixelRatio.get()),\n        };\n    }\n    static pickScale(scales, deviceScale) {\n        for (let i = 0; i < scales.length; i++) {\n            if (scales[i] >= deviceScale) {\n                return scales[i];\n            }\n        }\n        return scales[scales.length - 1] || 1;\n    }\n}\n//# sourceMappingURL=AssetSourceResolver.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-asset/build/AssetSourceResolver.js?");

/***/ }),

/***/ "./node_modules/expo-asset/build/AssetSources.js":
/*!*******************************************************!*\
  !*** ./node_modules/expo-asset/build/AssetSources.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pathJoin: () => (/* binding */ pathJoin),\n/* harmony export */   resolveUri: () => (/* binding */ resolveUri),\n/* harmony export */   selectAssetSource: () => (/* binding */ selectAssetSource)\n/* harmony export */ });\n/* harmony import */ var expo_modules_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! expo-modules-core */ \"./node_modules/expo-modules-core/build/Platform.js\");\n/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-native */ \"./node_modules/react-native/index.js\");\n/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_native__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _AssetSourceResolver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AssetSourceResolver */ \"./node_modules/expo-asset/build/AssetSourceResolver.js\");\n/* harmony import */ var _PlatformUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PlatformUtils */ \"./node_modules/expo-asset/build/PlatformUtils.js\");\n\n\n\n\n/**\n * Selects the best file for the given asset (ex: choosing the best scale for images) and returns\n * a { uri, hash } pair for the specific asset file.\n *\n * If the asset isn't an image with multiple scales, the first file is selected.\n */\nfunction selectAssetSource(meta) {\n    // This logic is based on that of AssetSourceResolver, with additional support for file hashes and\n    // explicitly provided URIs\n    const scale = _AssetSourceResolver__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pickScale(meta.scales, react_native__WEBPACK_IMPORTED_MODULE_0__.PixelRatio.get());\n    const index = meta.scales.findIndex((s) => s === scale);\n    const hash = meta.fileHashes ? meta.fileHashes[index] ?? meta.fileHashes[0] : meta.hash;\n    // Allow asset processors to directly provide the URL to load\n    const uri = meta.fileUris ? meta.fileUris[index] ?? meta.fileUris[0] : meta.uri;\n    if (uri) {\n        return { uri: resolveUri(uri), hash };\n    }\n    const fileScale = scale === 1 ? '' : `@${scale}x`;\n    const fileExtension = meta.type ? `.${encodeURIComponent(meta.type)}` : '';\n    const suffix = `/${encodeURIComponent(meta.name)}${fileScale}${fileExtension}`;\n    const params = new URLSearchParams({\n        platform: expo_modules_core__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OS,\n        hash: meta.hash,\n    });\n    // For assets with a specified absolute URL, we use the existing origin instead of prepending the\n    // development server or production CDN URL origin\n    if (/^https?:\\/\\//.test(meta.httpServerLocation)) {\n        const uri = meta.httpServerLocation + suffix + '?' + params;\n        return { uri, hash };\n    }\n    // For assets during development using manifest2, we use the development server's URL origin\n    const manifest2 = (0,_PlatformUtils__WEBPACK_IMPORTED_MODULE_3__.getManifest2)();\n    const devServerUrl = manifest2?.extra?.expoGo?.developer\n        ? 'http://' + manifest2.extra.expoGo.debuggerHost\n        : null;\n    if (devServerUrl) {\n        const baseUrl = new URL(meta.httpServerLocation + suffix, devServerUrl);\n        baseUrl.searchParams.set('platform', expo_modules_core__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OS);\n        baseUrl.searchParams.set('hash', meta.hash);\n        return {\n            uri: baseUrl.href,\n            hash,\n        };\n    }\n    // Temporary fallback for loading assets in Expo Go home\n    if (react_native__WEBPACK_IMPORTED_MODULE_0__.NativeModules.ExponentKernel) {\n        return { uri: `https://classic-assets.eascdn.net/~assets/${encodeURIComponent(hash)}`, hash };\n    }\n    // In correctly configured apps, we arrive here if the asset is locally available on disk due to\n    // being managed by expo-updates, and `getLocalAssetUri(hash)` must return a local URI for this\n    // hash. Since the asset is local, we don't have a remote URL and specify an invalid URL (an empty\n    // string) as a placeholder.\n    return { uri: '', hash };\n}\n/**\n * Resolves the given URI to an absolute URI. If the given URI is already an absolute URI, it is\n * simply returned. Otherwise, if it is a relative URI, it is resolved relative to the manifest's\n * base URI.\n */\nfunction resolveUri(uri) {\n    // `manifestBaseUrl` is always an absolute URL or `null`.\n    return _PlatformUtils__WEBPACK_IMPORTED_MODULE_3__.manifestBaseUrl ? new URL(uri, _PlatformUtils__WEBPACK_IMPORTED_MODULE_3__.manifestBaseUrl).href : uri;\n}\n// A very cheap path canonicalization like path.join but without depending on a `path` polyfill.\nfunction pathJoin(...paths) {\n    // Start by simply combining paths, without worrying about \"..\" or \".\"\n    const combined = paths\n        .map((part, index) => {\n        if (index === 0) {\n            return part.trim().replace(/\\/*$/, '');\n        }\n        return part.trim().replace(/(^\\/*|\\/*$)/g, '');\n    })\n        .filter((part) => part.length > 0)\n        .join('/')\n        .split('/');\n    // Handle \"..\" and \".\" in paths\n    const resolved = [];\n    for (const part of combined) {\n        if (part === '..') {\n            resolved.pop(); // Remove the last element from the result\n        }\n        else if (part !== '.') {\n            resolved.push(part);\n        }\n    }\n    return resolved.join('/');\n}\n//# sourceMappingURL=AssetSources.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-asset/build/AssetSources.js?");

/***/ }),

/***/ "./node_modules/expo-asset/build/AssetUris.js":
/*!****************************************************!*\
  !*** ./node_modules/expo-asset/build/AssetUris.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFileExtension: () => (/* binding */ getFileExtension),\n/* harmony export */   getFilename: () => (/* binding */ getFilename),\n/* harmony export */   getManifestBaseUrl: () => (/* binding */ getManifestBaseUrl)\n/* harmony export */ });\nfunction getFilename(url) {\n    const { pathname, searchParams } = new URL(url, 'https://e');\n    // When attached to a dev server, we use `unstable_path` to represent the file path. This ensures\n    // the file name is not canonicalized by the browser.\n    // NOTE(EvanBacon): This is technically not tied to `__DEV__` as it's possible to use this while bundling in production\n    // mode.\n    if (__DEV__) {\n        if (searchParams.has('unstable_path')) {\n            const encodedFilePath = decodeURIComponent(searchParams.get('unstable_path'));\n            return getBasename(encodedFilePath);\n        }\n    }\n    return getBasename(pathname);\n}\nfunction getBasename(pathname) {\n    return pathname.substring(pathname.lastIndexOf('/') + 1);\n}\nfunction getFileExtension(url) {\n    const filename = getFilename(url);\n    const dotIndex = filename.lastIndexOf('.');\n    // Ignore leading dots for hidden files\n    return dotIndex > 0 ? filename.substring(dotIndex) : '';\n}\n/**\n * Returns the base URL from a manifest's URL. For example, given a manifest hosted at\n * https://example.com/app/manifest.json, the base URL would be https://example.com/app/. Query\n * parameters and fragments also are removed.\n *\n * For an Expo-hosted project with a manifest hosted at https://exp.host/@user/project/index.exp, the\n * base URL would be https://exp.host/@user/project.\n *\n * We also normalize the \"exp\" protocol to \"http\" to handle internal URLs with the Expo schemes used\n * to tell the OS to open the URLs in the the Expo client.\n */\nfunction getManifestBaseUrl(manifestUrl) {\n    const urlObject = new URL(manifestUrl);\n    let nextProtocol = urlObject.protocol;\n    // Change the scheme to http(s) if it is exp(s)\n    if (nextProtocol === 'exp:') {\n        nextProtocol = 'http:';\n    }\n    else if (nextProtocol === 'exps:') {\n        nextProtocol = 'https:';\n    }\n    urlObject.protocol = nextProtocol;\n    // Trim filename, query parameters, and fragment, if any\n    const directory = urlObject.pathname.substring(0, urlObject.pathname.lastIndexOf('/') + 1);\n    urlObject.pathname = directory;\n    urlObject.search = '';\n    urlObject.hash = '';\n    // The URL spec doesn't allow for changing the protocol to `http` or `https`\n    // without a port set so instead, we'll just swap the protocol manually.\n    return urlObject.protocol !== nextProtocol\n        ? urlObject.href.replace(urlObject.protocol, nextProtocol)\n        : urlObject.href;\n}\n//# sourceMappingURL=AssetUris.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-asset/build/AssetUris.js?");

/***/ }),

/***/ "./node_modules/expo-asset/build/ExpoAsset.js":
/*!****************************************************!*\
  !*** ./node_modules/expo-asset/build/ExpoAsset.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   downloadAsync: () => (/* binding */ downloadAsync)\n/* harmony export */ });\n/* harmony import */ var expo_modules_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! expo-modules-core */ \"./node_modules/expo-modules-core/build/requireNativeModule.js\");\n\nconst AssetModule = (0,expo_modules_core__WEBPACK_IMPORTED_MODULE_0__.requireNativeModule)('ExpoAsset');\n/**\n * Downloads the asset from the given URL to a local cache and returns the local URL of the cached\n * file.\n *\n * If there is already a locally cached file and its MD5 hash matches the given `md5Hash` parameter,\n * if present, the remote asset is not downloaded. The `hash` property is included in Metro's asset\n * metadata objects when this module's `hashAssetFiles` plugin is used, which is the typical way the\n * `md5Hash` parameter of this function is provided.\n */\nasync function downloadAsync(url, md5Hash, type) {\n    return AssetModule.downloadAsync(url, md5Hash, type);\n}\n//# sourceMappingURL=ExpoAsset.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-asset/build/ExpoAsset.js?");

/***/ }),

/***/ "./node_modules/expo-asset/build/ImageAssets.js":
/*!******************************************************!*\
  !*** ./node_modules/expo-asset/build/ImageAssets.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getImageInfoAsync: () => (/* binding */ getImageInfoAsync),\n/* harmony export */   isImageType: () => (/* binding */ isImageType)\n/* harmony export */ });\n/* harmony import */ var expo_modules_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! expo-modules-core */ \"./node_modules/expo-modules-core/build/Platform.js\");\n/* harmony import */ var _AssetUris__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AssetUris */ \"./node_modules/expo-asset/build/AssetUris.js\");\n/* eslint-env browser */\n\n\nfunction isImageType(type) {\n    return /^(jpeg|jpg|gif|png|bmp|webp|heic)$/i.test(type);\n}\nfunction getImageInfoAsync(url) {\n    if (!expo_modules_core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isDOMAvailable) {\n        return Promise.resolve({ name: (0,_AssetUris__WEBPACK_IMPORTED_MODULE_1__.getFilename)(url), width: 0, height: 0 });\n    }\n    return new Promise((resolve, reject) => {\n        const img = new Image();\n        img.onerror = reject;\n        img.onload = () => {\n            resolve({\n                name: (0,_AssetUris__WEBPACK_IMPORTED_MODULE_1__.getFilename)(url),\n                width: img.naturalWidth,\n                height: img.naturalHeight,\n            });\n        };\n        img.src = url;\n    });\n}\n//# sourceMappingURL=ImageAssets.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-asset/build/ImageAssets.js?");

/***/ }),

/***/ "./node_modules/expo-asset/build/LocalAssets.js":
/*!******************************************************!*\
  !*** ./node_modules/expo-asset/build/LocalAssets.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getLocalAssetUri: () => (/* binding */ getLocalAssetUri)\n/* harmony export */ });\n/* harmony import */ var _PlatformUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PlatformUtils */ \"./node_modules/expo-asset/build/PlatformUtils.js\");\n\n// localAssets are provided by the expo-updates module\nconst localAssets = (0,_PlatformUtils__WEBPACK_IMPORTED_MODULE_0__.getLocalAssets)();\n/**\n * Returns the URI of a local asset from its hash, or null if the asset is not available locally\n */\nfunction getLocalAssetUri(hash, type) {\n    const localAssetsKey = hash;\n    const legacyLocalAssetsKey = `${hash}.${type ?? ''}`;\n    switch (true) {\n        case localAssetsKey in localAssets: {\n            return localAssets[localAssetsKey];\n        }\n        case legacyLocalAssetsKey in localAssets: {\n            // legacy updates store assets with an extension\n            return localAssets[legacyLocalAssetsKey];\n        }\n        default:\n            return null;\n    }\n}\n//# sourceMappingURL=LocalAssets.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-asset/build/LocalAssets.js?");

/***/ }),

/***/ "./node_modules/expo-asset/build/PlatformUtils.js":
/*!********************************************************!*\
  !*** ./node_modules/expo-asset/build/PlatformUtils.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IS_ENV_WITH_LOCAL_ASSETS: () => (/* binding */ IS_ENV_WITH_LOCAL_ASSETS),\n/* harmony export */   getLocalAssets: () => (/* binding */ getLocalAssets),\n/* harmony export */   getManifest2: () => (/* binding */ getManifest2),\n/* harmony export */   manifestBaseUrl: () => (/* binding */ manifestBaseUrl)\n/* harmony export */ });\n/* harmony import */ var expo_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! expo-constants */ \"./node_modules/expo-constants/build/Constants.js\");\n/* harmony import */ var expo_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! expo-constants */ \"./node_modules/expo-constants/build/Constants.types.js\");\n/* harmony import */ var expo_modules_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! expo-modules-core */ \"./node_modules/expo-modules-core/build/requireNativeModule.js\");\n/* harmony import */ var _AssetUris__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AssetUris */ \"./node_modules/expo-asset/build/AssetUris.js\");\n\n\n\nconst ExpoUpdates = (0,expo_modules_core__WEBPACK_IMPORTED_MODULE_0__.requireOptionalNativeModule)('ExpoUpdates');\nconst isRunningInExpoGo = expo_constants__WEBPACK_IMPORTED_MODULE_1__[\"default\"].appOwnership === expo_constants__WEBPACK_IMPORTED_MODULE_2__.AppOwnership.Expo;\n// expo-updates (and Expo Go expo-updates override) manages assets from updates and exposes\n// the ExpoUpdates.localAssets constant containing information about the assets.\nconst expoUpdatesIsInstalledAndEnabled = !!ExpoUpdates?.isEnabled;\nconst expoUpdatesIsUsingEmbeddedAssets = ExpoUpdates?.isUsingEmbeddedAssets;\n// if expo-updates is installed but we're running directly from the embedded bundle, we don't want\n// to override the AssetSourceResolver.\nconst shouldUseUpdatesAssetResolution = expoUpdatesIsInstalledAndEnabled && !expoUpdatesIsUsingEmbeddedAssets;\n// Expo Go always uses the updates module for asset resolution (local assets) since it\n// overrides the expo-updates module.\nconst IS_ENV_WITH_LOCAL_ASSETS = isRunningInExpoGo || shouldUseUpdatesAssetResolution;\n// Get the localAssets property from the ExpoUpdates native module so that we do\n// not need to include expo-updates as a dependency of expo-asset\nfunction getLocalAssets() {\n    return ExpoUpdates?.localAssets ?? {};\n}\nfunction getManifest2() {\n    return expo_constants__WEBPACK_IMPORTED_MODULE_1__[\"default\"].__unsafeNoWarnManifest2;\n}\n// Compute manifest base URL if available\nconst manifestBaseUrl = expo_constants__WEBPACK_IMPORTED_MODULE_1__[\"default\"].experienceUrl\n    ? (0,_AssetUris__WEBPACK_IMPORTED_MODULE_3__.getManifestBaseUrl)(expo_constants__WEBPACK_IMPORTED_MODULE_1__[\"default\"].experienceUrl)\n    : null;\n//# sourceMappingURL=PlatformUtils.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-asset/build/PlatformUtils.js?");

/***/ }),

/***/ "./node_modules/expo-asset/build/resolveAssetSource.js":
/*!*************************************************************!*\
  !*** ./node_modules/expo-asset/build/resolveAssetSource.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ resolveAssetSource),\n/* harmony export */   pickScale: () => (/* binding */ pickScale),\n/* harmony export */   setCustomSourceTransformer: () => (/* binding */ setCustomSourceTransformer)\n/* harmony export */ });\n/* harmony import */ var _react_native_assets_registry_registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-native/assets-registry/registry */ \"./node_modules/@react-native/assets-registry/registry.js\");\n/* harmony import */ var _react_native_assets_registry_registry__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_react_native_assets_registry_registry__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _AssetSourceResolver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AssetSourceResolver */ \"./node_modules/expo-asset/build/AssetSourceResolver.js\");\n\n\nlet _customSourceTransformer;\nfunction setCustomSourceTransformer(transformer) {\n    _customSourceTransformer = transformer;\n}\n/**\n * `source` is either a number (opaque type returned by require('./foo.png'))\n * or an `ImageSource` like { uri: '<http location || file path>' }\n */\nfunction resolveAssetSource(source) {\n    if (typeof source === 'object') {\n        return source;\n    }\n    const asset = (0,_react_native_assets_registry_registry__WEBPACK_IMPORTED_MODULE_0__.getAssetByID)(source);\n    if (!asset) {\n        return null;\n    }\n    const resolver = new _AssetSourceResolver__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\n    // Doesn't matter since this is removed on web\n    'https://expo.dev', null, asset);\n    if (_customSourceTransformer) {\n        return _customSourceTransformer(resolver);\n    }\n    return resolver.defaultAsset();\n}\nObject.defineProperty(resolveAssetSource, 'setCustomSourceTransformer', {\n    get() {\n        return setCustomSourceTransformer;\n    },\n});\nconst { pickScale } = _AssetSourceResolver__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n//# sourceMappingURL=resolveAssetSource.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-asset/build/resolveAssetSource.js?");

/***/ }),

/***/ "./node_modules/expo-constants/build/Constants.js":
/*!********************************************************!*\
  !*** ./node_modules/expo-constants/build/Constants.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AppOwnership: () => (/* reexport safe */ _Constants_types__WEBPACK_IMPORTED_MODULE_1__.AppOwnership),\n/* harmony export */   ExecutionEnvironment: () => (/* reexport safe */ _Constants_types__WEBPACK_IMPORTED_MODULE_1__.ExecutionEnvironment),\n/* harmony export */   UserInterfaceIdiom: () => (/* reexport safe */ _Constants_types__WEBPACK_IMPORTED_MODULE_1__.UserInterfaceIdiom),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var expo_modules_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! expo-modules-core */ \"./node_modules/expo-modules-core/build/requireNativeModule.js\");\n/* harmony import */ var expo_modules_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! expo-modules-core */ \"./node_modules/expo-modules-core/build/errors/CodedError.js\");\n/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-native */ \"./node_modules/react-native/index.js\");\n/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_native__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Constants_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Constants.types */ \"./node_modules/expo-constants/build/Constants.types.js\");\n/* harmony import */ var _ExponentConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ExponentConstants */ \"./node_modules/expo-constants/build/ExponentConstants.js\");\n\n\n\n\n\nif (!_ExponentConstants__WEBPACK_IMPORTED_MODULE_2__[\"default\"]) {\n    console.warn(\"No native ExponentConstants module found, are you sure the expo-constants's module is linked properly?\");\n}\nconst ExpoUpdates = (0,expo_modules_core__WEBPACK_IMPORTED_MODULE_3__.requireOptionalNativeModule)('ExpoUpdates');\nlet rawUpdatesManifest = null;\n// If expo-updates defines a non-empty manifest, prefer that one\nif (ExpoUpdates) {\n    let updatesManifest;\n    if (ExpoUpdates.manifest) {\n        updatesManifest = ExpoUpdates.manifest;\n    }\n    else if (ExpoUpdates.manifestString) {\n        updatesManifest = JSON.parse(ExpoUpdates.manifestString);\n    }\n    if (updatesManifest && Object.keys(updatesManifest).length > 0) {\n        rawUpdatesManifest = updatesManifest;\n    }\n}\n// If dev-launcher defines a non-empty manifest, prefer that one\nlet rawDevLauncherManifest = null;\nif (react_native__WEBPACK_IMPORTED_MODULE_0__.NativeModules.EXDevLauncher) {\n    let devLauncherManifest;\n    if (react_native__WEBPACK_IMPORTED_MODULE_0__.NativeModules.EXDevLauncher.manifestString) {\n        devLauncherManifest = JSON.parse(react_native__WEBPACK_IMPORTED_MODULE_0__.NativeModules.EXDevLauncher.manifestString);\n    }\n    if (devLauncherManifest && Object.keys(devLauncherManifest).length > 0) {\n        rawDevLauncherManifest = devLauncherManifest;\n    }\n}\n// Fall back to ExponentConstants.manifest if we don't have one from Updates\nlet rawAppConfig = null;\nif (_ExponentConstants__WEBPACK_IMPORTED_MODULE_2__[\"default\"] && _ExponentConstants__WEBPACK_IMPORTED_MODULE_2__[\"default\"].manifest) {\n    const appConfig = _ExponentConstants__WEBPACK_IMPORTED_MODULE_2__[\"default\"].manifest;\n    // On Android we pass the manifest in JSON form so this step is necessary\n    if (typeof appConfig === 'string') {\n        rawAppConfig = JSON.parse(appConfig);\n    }\n    else {\n        rawAppConfig = appConfig;\n    }\n}\nlet rawManifest = rawUpdatesManifest ?? rawDevLauncherManifest ?? rawAppConfig;\nconst { name, appOwnership, ...nativeConstants } = (_ExponentConstants__WEBPACK_IMPORTED_MODULE_2__[\"default\"] || {});\nconst constants = {\n    ...nativeConstants,\n    // Ensure this is null in bare workflow\n    appOwnership: appOwnership ?? null,\n};\nObject.defineProperties(constants, {\n    /**\n     * Use `manifest` property by default.\n     * This property is only used for internal purposes.\n     * It behaves similarly to the original one, but suppresses warning upon no manifest available.\n     * `expo-asset` uses it to prevent users from seeing mentioned warning.\n     */\n    __unsafeNoWarnManifest: {\n        get() {\n            const maybeManifest = getManifest(true);\n            if (!maybeManifest || !isEmbeddedManifest(maybeManifest)) {\n                return null;\n            }\n            return maybeManifest;\n        },\n        enumerable: false,\n    },\n    __unsafeNoWarnManifest2: {\n        get() {\n            const maybeManifest = getManifest(true);\n            if (!maybeManifest || !isExpoUpdatesManifest(maybeManifest)) {\n                return null;\n            }\n            return maybeManifest;\n        },\n        enumerable: false,\n    },\n    manifest: {\n        get() {\n            const maybeManifest = getManifest();\n            if (!maybeManifest || !isEmbeddedManifest(maybeManifest)) {\n                return null;\n            }\n            return maybeManifest;\n        },\n        enumerable: true,\n    },\n    manifest2: {\n        get() {\n            const maybeManifest = getManifest();\n            if (!maybeManifest || !isExpoUpdatesManifest(maybeManifest)) {\n                return null;\n            }\n            return maybeManifest;\n        },\n        enumerable: true,\n    },\n    expoConfig: {\n        get() {\n            const maybeManifest = getManifest(true);\n            if (!maybeManifest) {\n                return null;\n            }\n            // if running an embedded update, maybeManifest is a EmbeddedManifest which doesn't have\n            // the expo config. Instead, the embedded expo-constants app.config should be used.\n            if (ExpoUpdates && ExpoUpdates.isEmbeddedLaunch) {\n                return rawAppConfig;\n            }\n            if (isExpoUpdatesManifest(maybeManifest)) {\n                return maybeManifest.extra?.expoClient ?? null;\n            }\n            else if (isEmbeddedManifest(maybeManifest)) {\n                return maybeManifest;\n            }\n            return null;\n        },\n        enumerable: true,\n    },\n    expoGoConfig: {\n        get() {\n            const maybeManifest = getManifest(true);\n            if (!maybeManifest) {\n                return null;\n            }\n            if (isExpoUpdatesManifest(maybeManifest)) {\n                return maybeManifest.extra?.expoGo ?? null;\n            }\n            else if (isEmbeddedManifest(maybeManifest)) {\n                return maybeManifest;\n            }\n            return null;\n        },\n        enumerable: true,\n    },\n    easConfig: {\n        get() {\n            const maybeManifest = getManifest(true);\n            if (!maybeManifest) {\n                return null;\n            }\n            if (isExpoUpdatesManifest(maybeManifest)) {\n                return maybeManifest.extra?.eas ?? null;\n            }\n            else if (isEmbeddedManifest(maybeManifest)) {\n                return maybeManifest;\n            }\n            return null;\n        },\n        enumerable: true,\n    },\n    __rawManifest_TEST: {\n        get() {\n            return rawManifest;\n        },\n        set(value) {\n            rawManifest = value;\n        },\n        enumerable: false,\n    },\n});\nfunction isEmbeddedManifest(manifest) {\n    return !isExpoUpdatesManifest(manifest);\n}\nfunction isExpoUpdatesManifest(manifest) {\n    return 'metadata' in manifest;\n}\nfunction getManifest(suppressWarning = false) {\n    if (!rawManifest) {\n        const invalidManifestType = rawManifest === null ? 'null' : 'undefined';\n        if (nativeConstants.executionEnvironment === _Constants_types__WEBPACK_IMPORTED_MODULE_1__.ExecutionEnvironment.Bare &&\n            react_native__WEBPACK_IMPORTED_MODULE_0__.Platform.OS !== 'web') {\n            if (!suppressWarning) {\n                console.warn(`Constants.manifest is ${invalidManifestType} because the embedded app.config could not be read. Ensure that you have installed the expo-constants build scripts if you need to read from Constants.manifest.`);\n            }\n        }\n        else if (nativeConstants.executionEnvironment === _Constants_types__WEBPACK_IMPORTED_MODULE_1__.ExecutionEnvironment.StoreClient ||\n            nativeConstants.executionEnvironment === _Constants_types__WEBPACK_IMPORTED_MODULE_1__.ExecutionEnvironment.Standalone) {\n            // If we somehow get here, this is a truly exceptional state to be in.\n            // Constants.manifest should *always* be defined in those contexts.\n            throw new expo_modules_core__WEBPACK_IMPORTED_MODULE_4__.CodedError('ERR_CONSTANTS_MANIFEST_UNAVAILABLE', `Constants.manifest is ${invalidManifestType}, must be an object.`);\n        }\n    }\n    return rawManifest;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (constants);\n//# sourceMappingURL=Constants.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-constants/build/Constants.js?");

/***/ }),

/***/ "./node_modules/expo-constants/build/Constants.types.js":
/*!**************************************************************!*\
  !*** ./node_modules/expo-constants/build/Constants.types.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AppOwnership: () => (/* binding */ AppOwnership),\n/* harmony export */   ExecutionEnvironment: () => (/* binding */ ExecutionEnvironment),\n/* harmony export */   UserInterfaceIdiom: () => (/* binding */ UserInterfaceIdiom)\n/* harmony export */ });\nvar AppOwnership;\n(function (AppOwnership) {\n    /**\n     * The experience is running inside of the Expo Go app.\n     */\n    AppOwnership[\"Expo\"] = \"expo\";\n})(AppOwnership || (AppOwnership = {}));\n// @docsMissing\nvar ExecutionEnvironment;\n(function (ExecutionEnvironment) {\n    ExecutionEnvironment[\"Bare\"] = \"bare\";\n    ExecutionEnvironment[\"Standalone\"] = \"standalone\";\n    ExecutionEnvironment[\"StoreClient\"] = \"storeClient\";\n})(ExecutionEnvironment || (ExecutionEnvironment = {}));\n// @needsAudit\n/**\n * Current supported values are `handset`, `tablet`, `desktop` and `tv`. CarPlay will show up\n * as `unsupported`.\n */\nvar UserInterfaceIdiom;\n(function (UserInterfaceIdiom) {\n    UserInterfaceIdiom[\"Handset\"] = \"handset\";\n    UserInterfaceIdiom[\"Tablet\"] = \"tablet\";\n    UserInterfaceIdiom[\"Desktop\"] = \"desktop\";\n    UserInterfaceIdiom[\"TV\"] = \"tv\";\n    UserInterfaceIdiom[\"Unsupported\"] = \"unsupported\";\n})(UserInterfaceIdiom || (UserInterfaceIdiom = {}));\n//# sourceMappingURL=Constants.types.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-constants/build/Constants.types.js?");

/***/ }),

/***/ "./node_modules/expo-constants/build/ExponentConstants.js":
/*!****************************************************************!*\
  !*** ./node_modules/expo-constants/build/ExponentConstants.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var expo_modules_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! expo-modules-core */ \"./node_modules/expo-modules-core/build/requireNativeModule.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,expo_modules_core__WEBPACK_IMPORTED_MODULE_0__.requireOptionalNativeModule)('ExponentConstants'));\n//# sourceMappingURL=ExponentConstants.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-constants/build/ExponentConstants.js?");

/***/ }),

/***/ "./node_modules/expo-font/build/ExpoFontLoader.js":
/*!********************************************************!*\
  !*** ./node_modules/expo-font/build/ExpoFontLoader.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var expo_modules_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! expo-modules-core */ \"./node_modules/expo-modules-core/build/requireNativeModule.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,expo_modules_core__WEBPACK_IMPORTED_MODULE_0__.requireNativeModule)('ExpoFontLoader'));\n//# sourceMappingURL=ExpoFontLoader.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-font/build/ExpoFontLoader.js?");

/***/ }),

/***/ "./node_modules/expo-font/build/Font.js":
/*!**********************************************!*\
  !*** ./node_modules/expo-font/build/Font.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FontDisplay: () => (/* reexport safe */ _Font_types__WEBPACK_IMPORTED_MODULE_7__.FontDisplay),\n/* harmony export */   isLoaded: () => (/* binding */ isLoaded),\n/* harmony export */   isLoading: () => (/* binding */ isLoading),\n/* harmony export */   loadAsync: () => (/* binding */ loadAsync),\n/* harmony export */   processFontFamily: () => (/* binding */ processFontFamily),\n/* harmony export */   unloadAllAsync: () => (/* binding */ unloadAllAsync),\n/* harmony export */   unloadAsync: () => (/* binding */ unloadAsync)\n/* harmony export */ });\n/* harmony import */ var expo_modules_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! expo-modules-core */ \"./node_modules/expo-modules-core/build/Platform.js\");\n/* harmony import */ var expo_modules_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! expo-modules-core */ \"./node_modules/expo-modules-core/build/errors/CodedError.js\");\n/* harmony import */ var expo_modules_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! expo-modules-core */ \"./node_modules/expo-modules-core/build/errors/UnavailabilityError.js\");\n/* harmony import */ var _ExpoFontLoader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ExpoFontLoader */ \"./node_modules/expo-font/build/ExpoFontLoader.js\");\n/* harmony import */ var _Font_types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Font.types */ \"./node_modules/expo-font/build/Font.types.js\");\n/* harmony import */ var _FontLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FontLoader */ \"./node_modules/expo-font/build/FontLoader.js\");\n/* harmony import */ var _memory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./memory */ \"./node_modules/expo-font/build/memory.js\");\n/* harmony import */ var _server__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./server */ \"./node_modules/expo-font/build/server.js\");\n\n\n\n\n\n\n// @needsAudit\n// note(brentvatne): at some point we may want to warn if this is called outside of a managed app.\n/**\n * Used to transform font family names to the scoped name. This does not need to\n * be called in standalone or bare apps but it will return unscoped font family\n * names if it is called in those contexts.\n *\n * @param fontFamily Name of font to process.\n * @returns Returns a name processed for use with the [current workflow](https://docs.expo.dev/archive/managed-vs-bare/).\n */\nfunction processFontFamily(fontFamily) {\n    if (!fontFamily || !(0,_FontLoader__WEBPACK_IMPORTED_MODULE_0__.fontFamilyNeedsScoping)(fontFamily)) {\n        return fontFamily;\n    }\n    if (!isLoaded(fontFamily)) {\n        if (__DEV__) {\n            if (isLoading(fontFamily)) {\n                console.warn(`You started loading the font \"${fontFamily}\", but used it before it finished loading. You need to wait for Font.loadAsync to complete before using the font.`);\n            }\n            else {\n                console.warn(`fontFamily \"${fontFamily}\" is not a system font and has not been loaded through expo-font.`);\n            }\n        }\n    }\n    return `ExpoFont-${(0,_FontLoader__WEBPACK_IMPORTED_MODULE_0__.getNativeFontName)(fontFamily)}`;\n}\n// @needsAudit\n/**\n * Synchronously detect if the font for `fontFamily` has finished loading.\n *\n * @param fontFamily The name used to load the `FontResource`.\n * @return Returns `true` if the font has fully loaded.\n */\nfunction isLoaded(fontFamily) {\n    if (expo_modules_core__WEBPACK_IMPORTED_MODULE_1__[\"default\"].OS === 'web') {\n        return fontFamily in _memory__WEBPACK_IMPORTED_MODULE_2__.loaded || !!_ExpoFontLoader__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isLoaded(fontFamily);\n    }\n    return fontFamily in _memory__WEBPACK_IMPORTED_MODULE_2__.loaded || _ExpoFontLoader__WEBPACK_IMPORTED_MODULE_3__[\"default\"].customNativeFonts?.includes(fontFamily);\n}\n// @needsAudit\n/**\n * Synchronously detect if the font for `fontFamily` is still being loaded.\n *\n * @param fontFamily The name used to load the `FontResource`.\n * @returns Returns `true` if the font is still loading.\n */\nfunction isLoading(fontFamily) {\n    return fontFamily in _memory__WEBPACK_IMPORTED_MODULE_2__.loadPromises;\n}\n// @needsAudit\n/**\n * Highly efficient method for loading fonts from static or remote resources which can then be used\n * with the platform's native text elements. In the browser this generates a `@font-face` block in\n * a shared style sheet for fonts. No CSS is needed to use this method.\n *\n * @param fontFamilyOrFontMap string or map of values that can be used as the [`fontFamily`](https://reactnative.dev/docs/text#style)\n * style prop with React Native Text elements.\n * @param source the font asset that should be loaded into the `fontFamily` namespace.\n *\n * @return Returns a promise that fulfils when the font has loaded. Often you may want to wrap the\n * method in a `try/catch/finally` to ensure the app continues if the font fails to load.\n */\nfunction loadAsync(fontFamilyOrFontMap, source) {\n    // NOTE(EvanBacon): Static render pass on web must be synchronous to collect all fonts.\n    // Because of this, `loadAsync` doesn't use the `async` keyword and deviates from the\n    // standard Expo SDK style guide.\n    const isServer = expo_modules_core__WEBPACK_IMPORTED_MODULE_1__[\"default\"].OS === 'web' && typeof window === 'undefined';\n    if (typeof fontFamilyOrFontMap === 'object') {\n        if (source) {\n            return Promise.reject(new expo_modules_core__WEBPACK_IMPORTED_MODULE_4__.CodedError(`ERR_FONT_API`, `No fontFamily can be used for the provided source: ${source}. The second argument of \\`loadAsync()\\` can only be used with a \\`string\\` value as the first argument.`));\n        }\n        const fontMap = fontFamilyOrFontMap;\n        const names = Object.keys(fontMap);\n        if (isServer) {\n            names.map((name) => (0,_server__WEBPACK_IMPORTED_MODULE_5__.registerStaticFont)(name, fontMap[name]));\n            return Promise.resolve();\n        }\n        return Promise.all(names.map((name) => loadFontInNamespaceAsync(name, fontMap[name]))).then(() => { });\n    }\n    if (isServer) {\n        (0,_server__WEBPACK_IMPORTED_MODULE_5__.registerStaticFont)(fontFamilyOrFontMap, source);\n        return Promise.resolve();\n    }\n    return loadFontInNamespaceAsync(fontFamilyOrFontMap, source);\n}\nasync function loadFontInNamespaceAsync(fontFamily, source) {\n    if (!source) {\n        throw new expo_modules_core__WEBPACK_IMPORTED_MODULE_4__.CodedError(`ERR_FONT_SOURCE`, `Cannot load null or undefined font source: { \"${fontFamily}\": ${source} }. Expected asset of type \\`FontSource\\` for fontFamily of name: \"${fontFamily}\"`);\n    }\n    if (_memory__WEBPACK_IMPORTED_MODULE_2__.loaded[fontFamily]) {\n        return;\n    }\n    if (_memory__WEBPACK_IMPORTED_MODULE_2__.loadPromises.hasOwnProperty(fontFamily)) {\n        return _memory__WEBPACK_IMPORTED_MODULE_2__.loadPromises[fontFamily];\n    }\n    // Important: we want all callers that concurrently try to load the same font to await the same\n    // promise. If we're here, we haven't created the promise yet. To ensure we create only one\n    // promise in the program, we need to create the promise synchronously without yielding the event\n    // loop from this point.\n    const asset = (0,_FontLoader__WEBPACK_IMPORTED_MODULE_0__.getAssetForSource)(source);\n    _memory__WEBPACK_IMPORTED_MODULE_2__.loadPromises[fontFamily] = (async () => {\n        try {\n            await (0,_FontLoader__WEBPACK_IMPORTED_MODULE_0__.loadSingleFontAsync)(fontFamily, asset);\n            _memory__WEBPACK_IMPORTED_MODULE_2__.loaded[fontFamily] = true;\n        }\n        finally {\n            delete _memory__WEBPACK_IMPORTED_MODULE_2__.loadPromises[fontFamily];\n        }\n    })();\n    await _memory__WEBPACK_IMPORTED_MODULE_2__.loadPromises[fontFamily];\n}\n// @needsAudit\n/**\n * Unloads all the custom fonts. This is used for testing.\n */\nasync function unloadAllAsync() {\n    if (!_ExpoFontLoader__WEBPACK_IMPORTED_MODULE_3__[\"default\"].unloadAllAsync) {\n        throw new expo_modules_core__WEBPACK_IMPORTED_MODULE_6__.UnavailabilityError('expo-font', 'unloadAllAsync');\n    }\n    if (Object.keys(_memory__WEBPACK_IMPORTED_MODULE_2__.loadPromises).length) {\n        throw new expo_modules_core__WEBPACK_IMPORTED_MODULE_4__.CodedError(`ERR_UNLOAD`, `Cannot unload fonts while they're still loading: ${Object.keys(_memory__WEBPACK_IMPORTED_MODULE_2__.loadPromises).join(', ')}`);\n    }\n    for (const fontFamily of Object.keys(_memory__WEBPACK_IMPORTED_MODULE_2__.loaded)) {\n        delete _memory__WEBPACK_IMPORTED_MODULE_2__.loaded[fontFamily];\n    }\n    await _ExpoFontLoader__WEBPACK_IMPORTED_MODULE_3__[\"default\"].unloadAllAsync();\n}\n// @needsAudit\n/**\n * Unload custom fonts matching the `fontFamily`s and display values provided.\n * Because fonts are automatically unloaded on every platform this is mostly used for testing.\n *\n * @param fontFamilyOrFontMap The name or names of the custom fonts that will be unloaded.\n * @param options When `fontFamilyOrFontMap` is a string, this should be the font source used to load\n * the custom font originally.\n */\nasync function unloadAsync(fontFamilyOrFontMap, options) {\n    if (!_ExpoFontLoader__WEBPACK_IMPORTED_MODULE_3__[\"default\"].unloadAsync) {\n        throw new expo_modules_core__WEBPACK_IMPORTED_MODULE_6__.UnavailabilityError('expo-font', 'unloadAsync');\n    }\n    if (typeof fontFamilyOrFontMap === 'object') {\n        if (options) {\n            throw new expo_modules_core__WEBPACK_IMPORTED_MODULE_4__.CodedError(`ERR_FONT_API`, `No fontFamily can be used for the provided options: ${options}. The second argument of \\`unloadAsync()\\` can only be used with a \\`string\\` value as the first argument.`);\n        }\n        const fontMap = fontFamilyOrFontMap;\n        const names = Object.keys(fontMap);\n        await Promise.all(names.map((name) => unloadFontInNamespaceAsync(name, fontMap[name])));\n        return;\n    }\n    return await unloadFontInNamespaceAsync(fontFamilyOrFontMap, options);\n}\nasync function unloadFontInNamespaceAsync(fontFamily, options) {\n    if (!_memory__WEBPACK_IMPORTED_MODULE_2__.loaded[fontFamily]) {\n        return;\n    }\n    else {\n        delete _memory__WEBPACK_IMPORTED_MODULE_2__.loaded[fontFamily];\n    }\n    // Important: we want all callers that concurrently try to load the same font to await the same\n    // promise. If we're here, we haven't created the promise yet. To ensure we create only one\n    // promise in the program, we need to create the promise synchronously without yielding the event\n    // loop from this point.\n    const nativeFontName = (0,_FontLoader__WEBPACK_IMPORTED_MODULE_0__.getNativeFontName)(fontFamily);\n    if (!nativeFontName) {\n        throw new expo_modules_core__WEBPACK_IMPORTED_MODULE_4__.CodedError(`ERR_FONT_FAMILY`, `Cannot unload an empty name`);\n    }\n    await _ExpoFontLoader__WEBPACK_IMPORTED_MODULE_3__[\"default\"].unloadAsync(nativeFontName, options);\n}\n\n//# sourceMappingURL=Font.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-font/build/Font.js?");

/***/ }),

/***/ "./node_modules/expo-font/build/Font.types.js":
/*!****************************************************!*\
  !*** ./node_modules/expo-font/build/Font.types.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FontDisplay: () => (/* binding */ FontDisplay)\n/* harmony export */ });\n// @needsAudit\n/**\n * Sets the [font-display](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-display)\n * for a given typeface. The default font value on web is `FontDisplay.AUTO`.\n * Even though setting the `fontDisplay` does nothing on native platforms, the default behavior\n * emulates `FontDisplay.SWAP` on flagship devices like iOS, Samsung, Pixel, etc. Default\n * functionality varies on One Plus devices. In the browser this value is set in the generated\n * `@font-face` CSS block and not as a style property meaning you cannot dynamically change this\n * value based on the element it's used in.\n * @platform web\n */\nvar FontDisplay;\n(function (FontDisplay) {\n    /**\n     * __(Default)__ The font display strategy is defined by the user agent or platform.\n     * This generally defaults to the text being invisible until the font is loaded.\n     * Good for buttons or banners that require a specific treatment.\n     */\n    FontDisplay[\"AUTO\"] = \"auto\";\n    /**\n     * Fallback text is rendered immediately with a default font while the desired font is loaded.\n     * This is good for making the content appear to load instantly and is usually preferred.\n     */\n    FontDisplay[\"SWAP\"] = \"swap\";\n    /**\n     * The text will be invisible until the font has loaded. If the font fails to load then nothing\n     * will appear - it's best to turn this off when debugging missing text.\n     */\n    FontDisplay[\"BLOCK\"] = \"block\";\n    /**\n     * Splits the behavior between `SWAP` and `BLOCK`.\n     * There will be a [100ms timeout](https://developers.google.com/web/updates/2016/02/font-display?hl=en)\n     * where the text with a custom font is invisible, after that the text will either swap to the\n     * styled text or it'll show the unstyled text and continue to load the custom font. This is good\n     * for buttons that need a custom font but should also be quickly available to screen-readers.\n     */\n    FontDisplay[\"FALLBACK\"] = \"fallback\";\n    /**\n     * This works almost identically to `FALLBACK`, the only difference is that the browser will\n     * decide to load the font based on slow connection speed or critical resource demand.\n     */\n    FontDisplay[\"OPTIONAL\"] = \"optional\";\n})(FontDisplay || (FontDisplay = {}));\n//# sourceMappingURL=Font.types.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-font/build/Font.types.js?");

/***/ }),

/***/ "./node_modules/expo-font/build/FontLoader.js":
/*!****************************************************!*\
  !*** ./node_modules/expo-font/build/FontLoader.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fontFamilyNeedsScoping: () => (/* binding */ fontFamilyNeedsScoping),\n/* harmony export */   getAssetForSource: () => (/* binding */ getAssetForSource),\n/* harmony export */   getNativeFontName: () => (/* binding */ getNativeFontName),\n/* harmony export */   loadSingleFontAsync: () => (/* binding */ loadSingleFontAsync)\n/* harmony export */ });\n/* harmony import */ var expo_asset__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! expo-asset */ \"./node_modules/expo-asset/build/Asset.js\");\n/* harmony import */ var expo_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! expo-constants */ \"./node_modules/expo-constants/build/Constants.js\");\n/* harmony import */ var expo_modules_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! expo-modules-core */ \"./node_modules/expo-modules-core/build/Platform.js\");\n/* harmony import */ var expo_modules_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! expo-modules-core */ \"./node_modules/expo-modules-core/build/errors/CodedError.js\");\n/* harmony import */ var _ExpoFontLoader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ExpoFontLoader */ \"./node_modules/expo-font/build/ExpoFontLoader.js\");\n\n\n\n\nconst isInExpoGo = expo_constants__WEBPACK_IMPORTED_MODULE_0__[\"default\"].appOwnership === 'expo';\nfunction fontFamilyNeedsScoping(name) {\n    return (isInExpoGo &&\n        expo_modules_core__WEBPACK_IMPORTED_MODULE_1__[\"default\"].OS !== 'ios' &&\n        !expo_constants__WEBPACK_IMPORTED_MODULE_0__[\"default\"].systemFonts.includes(name) &&\n        name !== 'System' &&\n        !name.includes(expo_constants__WEBPACK_IMPORTED_MODULE_0__[\"default\"].sessionId));\n}\nfunction getAssetForSource(source) {\n    if (source instanceof expo_asset__WEBPACK_IMPORTED_MODULE_2__.Asset) {\n        return source;\n    }\n    if (typeof source === 'string') {\n        return expo_asset__WEBPACK_IMPORTED_MODULE_2__.Asset.fromURI(source);\n    }\n    else if (typeof source === 'number') {\n        return expo_asset__WEBPACK_IMPORTED_MODULE_2__.Asset.fromModule(source);\n    }\n    else if (typeof source === 'object' && typeof source.uri !== 'undefined') {\n        return getAssetForSource(source.uri);\n    }\n    // @ts-ignore Error: Type 'string' is not assignable to type 'Asset'\n    // We can't have a string here, we would have thrown an error if !isWeb\n    // or returned Asset.fromModule if isWeb.\n    return source;\n}\nasync function loadSingleFontAsync(name, input) {\n    const asset = input;\n    if (!asset.downloadAsync) {\n        throw new expo_modules_core__WEBPACK_IMPORTED_MODULE_3__.CodedError(`ERR_FONT_SOURCE`, '`loadSingleFontAsync` expected resource of type `Asset` from expo-asset on native');\n    }\n    await asset.downloadAsync();\n    if (!asset.downloaded) {\n        throw new expo_modules_core__WEBPACK_IMPORTED_MODULE_3__.CodedError(`ERR_DOWNLOAD`, `Failed to download asset for font \"${name}\"`);\n    }\n    await _ExpoFontLoader__WEBPACK_IMPORTED_MODULE_4__[\"default\"].loadAsync(getNativeFontName(name), asset.localUri);\n}\nfunction getNativeFontName(name) {\n    if (fontFamilyNeedsScoping(name)) {\n        return `${expo_constants__WEBPACK_IMPORTED_MODULE_0__[\"default\"].sessionId}-${name}`;\n    }\n    else {\n        return name;\n    }\n}\n//# sourceMappingURL=FontLoader.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-font/build/FontLoader.js?");

/***/ }),

/***/ "./node_modules/expo-font/build/memory.js":
/*!************************************************!*\
  !*** ./node_modules/expo-font/build/memory.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loadPromises: () => (/* binding */ loadPromises),\n/* harmony export */   loaded: () => (/* binding */ loaded)\n/* harmony export */ });\nconst loaded = {};\nconst loadPromises = {};\n//# sourceMappingURL=memory.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-font/build/memory.js?");

/***/ }),

/***/ "./node_modules/expo-font/build/server.js":
/*!************************************************!*\
  !*** ./node_modules/expo-font/build/server.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getServerResources: () => (/* binding */ getServerResources),\n/* harmony export */   registerStaticFont: () => (/* binding */ registerStaticFont),\n/* harmony export */   resetServerContext: () => (/* binding */ resetServerContext)\n/* harmony export */ });\n/* harmony import */ var expo_modules_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! expo-modules-core */ \"./node_modules/expo-modules-core/build/errors/CodedError.js\");\n/* harmony import */ var _ExpoFontLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ExpoFontLoader */ \"./node_modules/expo-font/build/ExpoFontLoader.js\");\n/* harmony import */ var _FontLoader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FontLoader */ \"./node_modules/expo-font/build/FontLoader.js\");\n\n\n\n/**\n * @returns the server resources that should be statically extracted.\n * @private\n */\nfunction getServerResources() {\n    return _ExpoFontLoader__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getServerResources();\n}\n/**\n * @returns clear the server resources from the global scope.\n * @private\n */\nfunction resetServerContext() {\n    return _ExpoFontLoader__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resetServerContext();\n}\nfunction registerStaticFont(fontFamily, source) {\n    // MUST BE A SYNC FUNCTION!\n    if (!source) {\n        throw new expo_modules_core__WEBPACK_IMPORTED_MODULE_1__.CodedError(`ERR_FONT_SOURCE`, `Cannot load null or undefined font source: { \"${fontFamily}\": ${source} }. Expected asset of type \\`FontSource\\` for fontFamily of name: \"${fontFamily}\"`);\n    }\n    const asset = (0,_FontLoader__WEBPACK_IMPORTED_MODULE_2__.getAssetForSource)(source);\n    (0,_FontLoader__WEBPACK_IMPORTED_MODULE_2__.loadSingleFontAsync)(fontFamily, asset);\n}\n//# sourceMappingURL=server.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-font/build/server.js?");

/***/ }),

/***/ "./node_modules/expo-modules-core/build/NativeModulesProxy.js":
/*!********************************************************************!*\
  !*** ./node_modules/expo-modules-core/build/NativeModulesProxy.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// We default to an empty object shim wherever we don't have an environment-specific implementation\n/**\n * @deprecated `NativeModulesProxy` is deprecated and might be removed in the future releases.\n * Use `requireNativeModule` or `requireOptionalNativeModule` instead.\n */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({});\n//# sourceMappingURL=NativeModulesProxy.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-modules-core/build/NativeModulesProxy.js?");

/***/ }),

/***/ "./node_modules/expo-modules-core/build/Platform.js":
/*!**********************************************************!*\
  !*** ./node_modules/expo-modules-core/build/Platform.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-native */ \"./node_modules/react-native/index.js\");\n/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_native__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _environment_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./environment/browser */ \"./node_modules/expo-modules-core/build/environment/browser.js\");\n\n\nconst Platform = {\n    /**\n     * Denotes the currently running platform.\n     * Can be one of ios, android, web.\n     */\n    OS: react_native__WEBPACK_IMPORTED_MODULE_0__.Platform.OS,\n    /**\n     * Returns the value with the matching platform.\n     * Object keys can be any of ios, android, native, web, default.\n     *\n     * @ios ios, native, default\n     * @android android, native, default\n     * @web web, default\n     */\n    select: react_native__WEBPACK_IMPORTED_MODULE_0__.Platform.select,\n    /**\n     * Denotes if the DOM API is available in the current environment.\n     * The DOM is not available in native React runtimes and Node.js.\n     */\n    isDOMAvailable: _environment_browser__WEBPACK_IMPORTED_MODULE_1__.isDOMAvailable,\n    /**\n     * Denotes if the current environment can attach event listeners\n     * to the window. This will return false in native React\n     * runtimes and Node.js.\n     */\n    canUseEventListeners: _environment_browser__WEBPACK_IMPORTED_MODULE_1__.canUseEventListeners,\n    /**\n     * Denotes if the current environment can inspect properties of the\n     * screen on which the current window is being rendered. This will\n     * return false in native React runtimes and Node.js.\n     */\n    canUseViewport: _environment_browser__WEBPACK_IMPORTED_MODULE_1__.canUseViewport,\n    /**\n     * If the JavaScript is being executed in a remote JavaScript environment.\n     * When `true`, synchronous native invocations cannot be executed.\n     */\n    isAsyncDebugging: _environment_browser__WEBPACK_IMPORTED_MODULE_1__.isAsyncDebugging,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Platform);\n//# sourceMappingURL=Platform.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-modules-core/build/Platform.js?");

/***/ }),

/***/ "./node_modules/expo-modules-core/build/ensureNativeModulesAreInstalled.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/expo-modules-core/build/ensureNativeModulesAreInstalled.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ensureNativeModulesAreInstalled: () => (/* binding */ ensureNativeModulesAreInstalled)\n/* harmony export */ });\n/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-native */ \"./node_modules/react-native/index.js\");\n/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_native__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\n * Ensures that the native modules are installed in the current runtime.\n * Otherwise, it synchronously calls a native function that installs them.\n */\nfunction ensureNativeModulesAreInstalled() {\n    if (globalThis.expo) {\n        return;\n    }\n    try {\n        if (react_native__WEBPACK_IMPORTED_MODULE_0__.Platform.OS === 'web') {\n            // Requiring web folder sets up the `globalThis.expo` object.\n            __webpack_require__(/*! ./web */ \"./node_modules/expo-modules-core/build/web/index.js\");\n        }\n        else {\n            // TODO: ExpoModulesCore shouldn't be optional here,\n            // but to keep backwards compatibility let's just ignore it in SDK 50.\n            // In most cases the modules were already installed from the native side.\n            react_native__WEBPACK_IMPORTED_MODULE_0__.NativeModules.ExpoModulesCore?.installModules();\n        }\n    }\n    catch (error) {\n        console.error(`Unable to install Expo modules: ${error}`);\n    }\n}\n//# sourceMappingURL=ensureNativeModulesAreInstalled.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-modules-core/build/ensureNativeModulesAreInstalled.js?");

/***/ }),

/***/ "./node_modules/expo-modules-core/build/environment/browser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/expo-modules-core/build/environment/browser.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canUseEventListeners: () => (/* binding */ canUseEventListeners),\n/* harmony export */   canUseViewport: () => (/* binding */ canUseViewport),\n/* harmony export */   isAsyncDebugging: () => (/* binding */ isAsyncDebugging),\n/* harmony export */   isDOMAvailable: () => (/* binding */ isDOMAvailable)\n/* harmony export */ });\n// In standard node environments there is no DOM API\nconst isDOMAvailable = false;\nconst canUseEventListeners = false;\nconst canUseViewport = false;\nlet isAsyncDebugging = false;\nif (__DEV__) {\n    // These native globals are injected by native React runtimes and not standard browsers\n    // we can use them to determine if the JS is being executed in Chrome.\n    isAsyncDebugging =\n        !__webpack_require__.g.nativeExtensions && !__webpack_require__.g.nativeCallSyncHook && !__webpack_require__.g.RN$Bridgeless;\n}\n//# sourceMappingURL=browser.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-modules-core/build/environment/browser.js?");

/***/ }),

/***/ "./node_modules/expo-modules-core/build/errors/CodedError.js":
/*!*******************************************************************!*\
  !*** ./node_modules/expo-modules-core/build/errors/CodedError.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CodedError: () => (/* binding */ CodedError)\n/* harmony export */ });\n/**\n * A general error class that should be used for all errors in Expo modules.\n * Guarantees a `code` field that can be used to differentiate between different\n * types of errors without further subclassing Error.\n */\nclass CodedError extends Error {\n    code;\n    info;\n    constructor(code, message) {\n        super(message);\n        this.code = code;\n    }\n}\n//# sourceMappingURL=CodedError.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-modules-core/build/errors/CodedError.js?");

/***/ }),

/***/ "./node_modules/expo-modules-core/build/errors/UnavailabilityError.js":
/*!****************************************************************************!*\
  !*** ./node_modules/expo-modules-core/build/errors/UnavailabilityError.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnavailabilityError: () => (/* binding */ UnavailabilityError)\n/* harmony export */ });\n/* harmony import */ var _CodedError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CodedError */ \"./node_modules/expo-modules-core/build/errors/CodedError.js\");\n/* harmony import */ var _Platform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Platform */ \"./node_modules/expo-modules-core/build/Platform.js\");\n\n\n/**\n * A class for errors to be thrown when a property is accessed which is\n * unavailable, unsupported, or not currently implemented on the running\n * platform.\n */\nclass UnavailabilityError extends _CodedError__WEBPACK_IMPORTED_MODULE_0__.CodedError {\n    constructor(moduleName, propertyName) {\n        super('ERR_UNAVAILABLE', `The method or property ${moduleName}.${propertyName} is not available on ${_Platform__WEBPACK_IMPORTED_MODULE_1__[\"default\"].OS}, are you sure you've linked all the native dependencies properly?`);\n    }\n}\n//# sourceMappingURL=UnavailabilityError.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-modules-core/build/errors/UnavailabilityError.js?");

/***/ }),

/***/ "./node_modules/expo-modules-core/build/requireNativeModule.js":
/*!*********************************************************************!*\
  !*** ./node_modules/expo-modules-core/build/requireNativeModule.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   requireNativeModule: () => (/* binding */ requireNativeModule),\n/* harmony export */   requireOptionalNativeModule: () => (/* binding */ requireOptionalNativeModule)\n/* harmony export */ });\n/* harmony import */ var _NativeModulesProxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./NativeModulesProxy */ \"./node_modules/expo-modules-core/build/NativeModulesProxy.js\");\n/* harmony import */ var _ensureNativeModulesAreInstalled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ensureNativeModulesAreInstalled */ \"./node_modules/expo-modules-core/build/ensureNativeModulesAreInstalled.js\");\n\n\n/**\n * Imports the native module registered with given name. In the first place it tries to load\n * the module installed through the JSI host object and then falls back to the bridge proxy module.\n * Notice that the modules loaded from the proxy may not support some features like synchronous functions.\n *\n * @param moduleName Name of the requested native module.\n * @returns Object representing the native module.\n * @throws Error when there is no native module with given name.\n */\nfunction requireNativeModule(moduleName) {\n    const nativeModule = requireOptionalNativeModule(moduleName);\n    if (!nativeModule) {\n        throw new Error(`Cannot find native module '${moduleName}'`);\n    }\n    return nativeModule;\n}\n/**\n * Imports the native module registered with the given name. The same as `requireNativeModule`,\n * but returns `null` when the module cannot be found instead of throwing an error.\n *\n * @param moduleName Name of the requested native module.\n * @returns Object representing the native module or `null` when it cannot be found.\n */\nfunction requireOptionalNativeModule(moduleName) {\n    (0,_ensureNativeModulesAreInstalled__WEBPACK_IMPORTED_MODULE_0__.ensureNativeModulesAreInstalled)();\n    return globalThis.expo?.modules?.[moduleName] ?? _NativeModulesProxy__WEBPACK_IMPORTED_MODULE_1__[\"default\"][moduleName] ?? null;\n}\n//# sourceMappingURL=requireNativeModule.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-modules-core/build/requireNativeModule.js?");

/***/ }),

/***/ "./node_modules/expo-modules-core/build/web/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/expo-modules-core/build/web/index.js ***!
  \***********************************************************/
/***/ (() => {

eval("//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo-modules-core/build/web/index.js?");

/***/ }),

/***/ "./node_modules/expo/build/Expo.fx.js":
/*!********************************************!*\
  !*** ./node_modules/expo/build/Expo.fx.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _winter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./winter */ \"./node_modules/expo/build/winter/index.js\");\n/* harmony import */ var expo_font__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! expo-font */ \"./node_modules/expo-font/build/Font.js\");\n/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-native */ \"./node_modules/react-native/index.js\");\n/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_native__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _environment_ExpoGo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./environment/ExpoGo */ \"./node_modules/expo/build/environment/ExpoGo.js\");\n/* harmony import */ var _errors_AppEntryNotFound__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./errors/AppEntryNotFound */ \"./node_modules/expo/build/errors/AppEntryNotFound.js\");\n/* harmony import */ var _errors_AppEntryNotFound__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_errors_AppEntryNotFound__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _errors_ExpoErrorManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./errors/ExpoErrorManager */ \"./node_modules/expo/build/errors/ExpoErrorManager.js\");\n// load expo-asset immediately to set a custom `source` transformer in React Native\n\n\n\n\n\n\n\n// If expo-font is installed and the style preprocessor is available, use it to parse fonts.\nif (react_native__WEBPACK_IMPORTED_MODULE_1__.StyleSheet.setStyleAttributePreprocessor) {\n    react_native__WEBPACK_IMPORTED_MODULE_1__.StyleSheet.setStyleAttributePreprocessor('fontFamily', expo_font__WEBPACK_IMPORTED_MODULE_2__.processFontFamily);\n}\nif ((0,_environment_ExpoGo__WEBPACK_IMPORTED_MODULE_3__.isRunningInExpoGo)()) {\n    // set up some improvements to commonly logged error messages stemming from react-native\n    const globalHandler = ErrorUtils.getGlobalHandler();\n    ErrorUtils.setGlobalHandler((0,_errors_ExpoErrorManager__WEBPACK_IMPORTED_MODULE_4__.createErrorHandler)(globalHandler));\n}\nif (true) {\n    // Register a default component and expect `registerRootComponent` to be called later and update it.\n    react_native__WEBPACK_IMPORTED_MODULE_1__.AppRegistry.registerComponent('main', () => _errors_AppEntryNotFound__WEBPACK_IMPORTED_MODULE_5__.AppEntryNotFound);\n}\n//# sourceMappingURL=Expo.fx.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo/build/Expo.fx.js?");

/***/ }),

/***/ "./node_modules/expo/build/environment/ExpoGo.js":
/*!*******************************************************!*\
  !*** ./node_modules/expo/build/environment/ExpoGo.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getExpoGoProjectConfig: () => (/* binding */ getExpoGoProjectConfig),\n/* harmony export */   isRunningInExpoGo: () => (/* binding */ isRunningInExpoGo)\n/* harmony export */ });\n/* harmony import */ var expo_modules_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! expo-modules-core */ \"./node_modules/expo-modules-core/build/requireNativeModule.js\");\n\n// ExpoGo module is available only when the app is run in Expo Go,\n// otherwise we use `null` instead of throwing an error.\nconst NativeExpoGoModule = (() => {\n    try {\n        return (0,expo_modules_core__WEBPACK_IMPORTED_MODULE_0__.requireNativeModule)('ExpoGo');\n    }\n    catch {\n        return null;\n    }\n})();\n/**\n * Returns a boolean value whether the app is running in Expo Go.\n */\nfunction isRunningInExpoGo() {\n    return NativeExpoGoModule != null;\n}\n/**\n * Returns an Expo Go project config from the manifest or `null` if the app is not running in Expo Go.\n */\nfunction getExpoGoProjectConfig() {\n    return NativeExpoGoModule?.projectConfig ?? null;\n}\n//# sourceMappingURL=ExpoGo.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo/build/environment/ExpoGo.js?");

/***/ }),

/***/ "./node_modules/expo/build/errors/AppEntryNotFound.js":
/*!************************************************************!*\
  !*** ./node_modules/expo/build/errors/AppEntryNotFound.js ***!
  \************************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (3:12)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n| import { StyleSheet, Text, View } from 'react-native';\\n| export function AppEntryNotFound() {\\n>     return (<View style={styles.container}>\\n|       <Text style={styles.errorTitle}>App entry not found</Text>\\n|       <Text style={styles.errorDescription}>\");\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo/build/errors/AppEntryNotFound.js?");

/***/ }),

/***/ "./node_modules/expo/build/errors/ExpoErrorManager.js":
/*!************************************************************!*\
  !*** ./node_modules/expo/build/errors/ExpoErrorManager.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createErrorHandler: () => (/* binding */ createErrorHandler),\n/* harmony export */   disableErrorHandling: () => (/* binding */ disableErrorHandling)\n/* harmony export */ });\nfunction createErrorHandler(originalHandler) {\n    return (error, isFatal) => originalHandler(error, isFatal);\n}\nfunction disableErrorHandling() { }\n//# sourceMappingURL=ExpoErrorManager.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo/build/errors/ExpoErrorManager.js?");

/***/ }),

/***/ "./node_modules/expo/build/launch/registerRootComponent.js":
/*!*****************************************************************!*\
  !*** ./node_modules/expo/build/launch/registerRootComponent.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ registerRootComponent)\n/* harmony export */ });\n/* harmony import */ var _Expo_fx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Expo.fx */ \"./node_modules/expo/build/Expo.fx.js\");\n/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-native */ \"./node_modules/react-native/index.js\");\n/* harmony import */ var react_native__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_native__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction registerRootComponent(component) {\n    let qualifiedComponent = component;\n    if (true) {\n        const { withDevTools } = __webpack_require__(/*! ./withDevTools */ \"./node_modules/expo/build/launch/withDevTools.js\");\n        qualifiedComponent = withDevTools(component);\n    }\n    react_native__WEBPACK_IMPORTED_MODULE_1__.AppRegistry.registerComponent('main', () => qualifiedComponent);\n    // Skip querying the DOM if we're in a Node.js environment.\n    if (react_native__WEBPACK_IMPORTED_MODULE_1__.Platform.OS === 'web' && typeof window !== 'undefined') {\n        const rootTag = document.getElementById('root');\n        if (true) {\n            if (!rootTag) {\n                throw new Error('Required HTML element with id \"root\" was not found in the document HTML.');\n            }\n        }\n        react_native__WEBPACK_IMPORTED_MODULE_1__.AppRegistry.runApplication('main', {\n            rootTag,\n            hydrate: process.env.EXPO_PUBLIC_USE_STATIC === '1',\n        });\n    }\n}\n//# sourceMappingURL=registerRootComponent.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo/build/launch/registerRootComponent.js?");

/***/ }),

/***/ "./node_modules/expo/build/launch/withDevTools.js":
/*!********************************************************!*\
  !*** ./node_modules/expo/build/launch/withDevTools.js ***!
  \********************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (18:15)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n|     function WithDevTools(props) {\\n|         useOptionalKeepAwake();\\n>         return <AppRootComponent {...props}/>;\\n|     }\\n|     if (process.env.NODE_ENV !== 'production') {\");\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo/build/launch/withDevTools.js?");

/***/ }),

/***/ "./node_modules/expo/build/winter/index.js":
/*!*************************************************!*\
  !*** ./node_modules/expo/build/winter/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./runtime */ \"./node_modules/expo/build/winter/runtime.js\");\n/* harmony import */ var _runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_runtime__WEBPACK_IMPORTED_MODULE_0__);\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo/build/winter/index.js?");

/***/ }),

/***/ "./node_modules/expo/build/winter/runtime.js":
/*!***************************************************!*\
  !*** ./node_modules/expo/build/winter/runtime.js ***!
  \***************************************************/
/***/ (() => {

eval("//# sourceMappingURL=runtime.js.map\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/expo/build/winter/runtime.js?");

/***/ }),

/***/ "./node_modules/react-native/index.js":
/*!********************************************!*\
  !*** ./node_modules/react-native/index.js ***!
  \********************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (14:7)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n| \\n| // APIs\\n> import typeof ActionSheetIOS from './Libraries/ActionSheetIOS/ActionSheetIOS';\\n| import typeof Alert from './Libraries/Alert/Alert';\\n| import typeof Animated from './Libraries/Animated/Animated';\");\n\n//# sourceURL=webpack://myAppFrontend/./node_modules/react-native/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ })()
;